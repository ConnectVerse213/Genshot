import {
  HSBasePlugin,
  afterTransition,
  dispatch,
  getClassProperty,
  isDirectChild,
  stringToBoolean
} from "./chunk-WHMMH7RJ.js";
import {
  __publicField
} from "./chunk-EQCVQC35.js";

// node_modules/preline/src/constants.ts
var BREAKPOINTS = {
  xs: 0,
  sm: 640,
  md: 768,
  lg: 1024,
  xl: 1280,
  "2xl": 1536
};

// node_modules/preline/src/plugins/accessibility-manager/index.ts
var HSAccessibilityObserver = class {
  constructor() {
    __publicField(this, "components", []);
    __publicField(this, "currentlyOpenedComponents", []);
    __publicField(this, "activeComponent", null);
    __publicField(this, "allowedKeybindings", /* @__PURE__ */ new Set([
      "Escape",
      "Enter",
      " ",
      "Space",
      "ArrowDown",
      "ArrowUp",
      "ArrowLeft",
      "ArrowRight",
      "Tab",
      "Home",
      "End"
    ]));
    this.initGlobalListeners();
  }
  initGlobalListeners() {
    document.addEventListener(
      "keydown",
      (evt) => this.handleGlobalKeydown(evt)
    );
    document.addEventListener(
      "focusin",
      (evt) => this.handleGlobalFocusin(evt)
    );
  }
  isAllowedKeybinding(evt) {
    if (this.allowedKeybindings.has(evt.key)) {
      return true;
    }
    if (evt.key.length === 1 && /^[a-zA-Z]$/.test(evt.key) && !evt.metaKey && !evt.ctrlKey && !evt.altKey && !evt.shiftKey) {
      return true;
    }
    return false;
  }
  getActiveComponent(el) {
    if (!el) return null;
    const containingComponents = this.components.filter(
      (comp) => comp.wrapper.contains(el) || comp.context && comp.context.contains(el)
    );
    if (containingComponents.length === 0) return null;
    if (containingComponents.length === 1) return containingComponents[0];
    let closestComponent = null;
    let minDistance = Number.MAX_SAFE_INTEGER;
    for (const comp of containingComponents) {
      let distance = 0;
      let current = el;
      while (current && current !== comp.wrapper && current !== comp.context) {
        distance++;
        current = current.parentElement;
      }
      if (distance < minDistance) {
        minDistance = distance;
        closestComponent = comp;
      }
    }
    return closestComponent;
  }
  handleGlobalFocusin(evt) {
    const target = evt.target;
    this.activeComponent = this.getActiveComponent(target);
  }
  handleGlobalKeydown(evt) {
    const target = evt.target;
    this.activeComponent = this.getActiveComponent(target);
    if (!this.activeComponent) return;
    if (!this.isAllowedKeybinding(evt)) {
      return;
    }
    switch (evt.key) {
      case "Escape":
        if (!this.activeComponent.isOpened) {
          const closestOpenParent = this.findClosestOpenParent(target);
          if (closestOpenParent == null ? void 0 : closestOpenParent.handlers.onEsc) {
            closestOpenParent.handlers.onEsc();
            evt.preventDefault();
            evt.stopPropagation();
          }
        } else if (this.activeComponent.handlers.onEsc) {
          this.activeComponent.handlers.onEsc();
          evt.preventDefault();
          evt.stopPropagation();
        }
        break;
      case "Enter":
        if (this.activeComponent.handlers.onEnter) {
          this.activeComponent.handlers.onEnter();
          evt.preventDefault();
          evt.stopPropagation();
        }
        break;
      case " ":
      case "Space":
        if (target.tagName === "INPUT" || target.tagName === "TEXTAREA") {
          return;
        }
        if (this.activeComponent.handlers.onSpace) {
          this.activeComponent.handlers.onSpace();
          evt.preventDefault();
          evt.stopPropagation();
        }
        break;
      case "ArrowDown":
      case "ArrowUp":
      case "ArrowLeft":
      case "ArrowRight":
        if (this.activeComponent.handlers.onArrow) {
          if (evt.metaKey || evt.ctrlKey || evt.altKey || evt.shiftKey) {
            return;
          }
          this.activeComponent.handlers.onArrow(evt);
          evt.preventDefault();
          evt.stopPropagation();
        }
        break;
      case "Tab":
        if (!this.activeComponent.handlers.onTab) break;
        const handler = evt.shiftKey ? this.activeComponent.handlers.onShiftTab : this.activeComponent.handlers.onTab;
        if (handler) handler();
        break;
      case "Home":
        if (this.activeComponent.handlers.onHome) {
          this.activeComponent.handlers.onHome();
          evt.preventDefault();
          evt.stopPropagation();
        }
        break;
      case "End":
        if (this.activeComponent.handlers.onEnd) {
          this.activeComponent.handlers.onEnd();
          evt.preventDefault();
          evt.stopPropagation();
        }
        break;
      default:
        if (this.activeComponent.handlers.onFirstLetter && evt.key.length === 1 && /^[a-zA-Z]$/.test(evt.key)) {
          this.activeComponent.handlers.onFirstLetter(evt.key);
          evt.preventDefault();
          evt.stopPropagation();
        }
        break;
    }
  }
  findClosestOpenParent(target) {
    let current = target.parentElement;
    while (current) {
      const parentComponent = this.currentlyOpenedComponents.find(
        (comp) => comp.wrapper === current && comp !== this.activeComponent
      );
      if (parentComponent) {
        return parentComponent;
      }
      current = current.parentElement;
    }
    return null;
  }
  registerComponent(wrapper, handlers, isOpened = true, name = "", selector = "", context) {
    const component = {
      wrapper,
      handlers,
      isOpened,
      name,
      selector,
      context,
      isRegistered: true
    };
    this.components.push(component);
    return component;
  }
  updateComponentState(component, isOpened) {
    component.isOpened = isOpened;
    if (isOpened) {
      if (!this.currentlyOpenedComponents.includes(component)) {
        this.currentlyOpenedComponents.push(component);
      }
    } else {
      this.currentlyOpenedComponents = this.currentlyOpenedComponents.filter(
        (comp) => comp !== component
      );
    }
  }
  unregisterComponent(component) {
    this.components = this.components.filter((comp) => comp !== component);
    this.currentlyOpenedComponents = this.currentlyOpenedComponents.filter(
      (comp) => comp !== component
    );
  }
  addAllowedKeybinding(key) {
    this.allowedKeybindings.add(key);
  }
  removeAllowedKeybinding(key) {
    this.allowedKeybindings.delete(key);
  }
  getAllowedKeybindings() {
    return Array.from(this.allowedKeybindings);
  }
};
var accessibility_manager_default = HSAccessibilityObserver;

// node_modules/preline/src/plugins/overlay/index.ts
var _HSOverlay = class _HSOverlay extends HSBasePlugin {
  constructor(el, options, events) {
    var _a, _b;
    super(el, options, events);
    __publicField(this, "accessibilityComponent");
    __publicField(this, "lastFocusedToggle", null);
    __publicField(this, "initiallyOpened");
    __publicField(this, "hiddenClass");
    __publicField(this, "emulateScrollbarSpace");
    __publicField(this, "isClosePrev");
    __publicField(this, "backdropClasses");
    __publicField(this, "backdropParent");
    __publicField(this, "backdropExtraClasses");
    __publicField(this, "animationTarget");
    __publicField(this, "openNextOverlay");
    __publicField(this, "autoHide");
    __publicField(this, "toggleButtons");
    __publicField(this, "toggleMinifierButtons");
    __publicField(this, "initContainer");
    __publicField(this, "isCloseWhenClickInside");
    __publicField(this, "isTabAccessibilityLimited");
    __publicField(this, "isLayoutAffect");
    __publicField(this, "hasAutofocus");
    __publicField(this, "hasDynamicZIndex");
    __publicField(this, "hasAbilityToCloseOnBackdropClick");
    __publicField(this, "openedBreakpoint");
    __publicField(this, "autoClose");
    __publicField(this, "autoCloseEqualityType");
    __publicField(this, "moveOverlayToBody");
    __publicField(this, "backdrop");
    __publicField(this, "initialZIndex", 0);
    __publicField(this, "onElementClickListener");
    __publicField(this, "onElementMinifierClickListener");
    __publicField(this, "onOverlayClickListener");
    __publicField(this, "onBackdropClickListener");
    this.toggleButtons = Array.from(
      document.querySelectorAll(`[data-hs-overlay="#${this.el.id}"]`)
    );
    const toggleDataOptions = this.collectToggleParameters(this.toggleButtons);
    this.toggleMinifierButtons = Array.from(
      document.querySelectorAll(`[data-hs-overlay-minifier="#${this.el.id}"]`)
    );
    const data = el.getAttribute("data-hs-overlay-options");
    const dataOptions = data ? JSON.parse(data) : {};
    const concatOptions = {
      ...dataOptions,
      ...toggleDataOptions,
      ...options
    };
    this.hiddenClass = (concatOptions == null ? void 0 : concatOptions.hiddenClass) || "hidden";
    this.emulateScrollbarSpace = (concatOptions == null ? void 0 : concatOptions.emulateScrollbarSpace) || false;
    this.isClosePrev = (concatOptions == null ? void 0 : concatOptions.isClosePrev) ?? true;
    this.backdropClasses = (concatOptions == null ? void 0 : concatOptions.backdropClasses) ?? "hs-overlay-backdrop transition duration fixed inset-0 bg-gray-900/50 dark:bg-neutral-900/80";
    this.backdropParent = typeof concatOptions.backdropParent === "string" ? document.querySelector(concatOptions.backdropParent) : document.body;
    this.backdropExtraClasses = (concatOptions == null ? void 0 : concatOptions.backdropExtraClasses) ?? "";
    this.moveOverlayToBody = (concatOptions == null ? void 0 : concatOptions.moveOverlayToBody) || null;
    this.openNextOverlay = false;
    this.autoHide = null;
    this.initContainer = ((_a = this.el) == null ? void 0 : _a.parentElement) || null;
    this.isCloseWhenClickInside = stringToBoolean(
      getClassProperty(this.el, "--close-when-click-inside", "false") || "false"
    );
    this.isTabAccessibilityLimited = stringToBoolean(
      getClassProperty(this.el, "--tab-accessibility-limited", "true") || "true"
    );
    this.isLayoutAffect = stringToBoolean(
      getClassProperty(this.el, "--is-layout-affect", "false") || "false"
    );
    this.hasAutofocus = stringToBoolean(
      getClassProperty(this.el, "--has-autofocus", "true") || "true"
    );
    this.hasDynamicZIndex = stringToBoolean(
      getClassProperty(this.el, "--has-dynamic-z-index", "false") || "false"
    );
    this.hasAbilityToCloseOnBackdropClick = stringToBoolean(
      this.el.getAttribute("data-hs-overlay-keyboard") || "true"
    );
    const autoCloseBreakpoint = getClassProperty(this.el, "--auto-close");
    const autoCloseEqualityType = getClassProperty(
      this.el,
      "--auto-close-equality-type"
    );
    const openedBreakpoint = getClassProperty(this.el, "--opened");
    this.autoClose = !isNaN(+autoCloseBreakpoint) && isFinite(+autoCloseBreakpoint) ? +autoCloseBreakpoint : BREAKPOINTS[autoCloseBreakpoint] || null;
    this.autoCloseEqualityType = autoCloseEqualityType ?? null;
    this.openedBreakpoint = (!isNaN(+openedBreakpoint) && isFinite(+openedBreakpoint) ? +openedBreakpoint : BREAKPOINTS[openedBreakpoint]) || null;
    this.animationTarget = ((_b = this == null ? void 0 : this.el) == null ? void 0 : _b.querySelector(".hs-overlay-animation-target")) || this.el;
    this.initialZIndex = parseInt(getComputedStyle(this.el).zIndex, 10);
    this.onElementClickListener = [];
    this.onElementMinifierClickListener = [];
    this.initiallyOpened = document.body.classList.contains(
      "hs-overlay-body-open"
    );
    this.init();
  }
  elementClick() {
    const payloadFn = () => {
      const payload = {
        el: this.el,
        isOpened: !!this.el.classList.contains("open")
      };
      this.fireEvent("toggleClicked", payload);
      dispatch("toggleClicked.hs.overlay", this.el, payload);
    };
    if (this.el.classList.contains("opened")) this.close(false, payloadFn);
    else this.open(payloadFn);
  }
  elementMinifierClick() {
    const payloadFn = () => {
      const payload = {
        el: this.el,
        isMinified: !!this.el.classList.contains("minified")
      };
      this.fireEvent("toggleMinifierClicked", payload);
      dispatch("toggleMinifierClicked.hs.overlay", this.el, payload);
    };
    if (this.el.classList.contains("minified")) this.minify(false, payloadFn);
    else this.minify(true, payloadFn);
  }
  minify(isMinified, cb = null) {
    if (isMinified) {
      this.el.classList.add("minified");
      document.body.classList.add("hs-overlay-minified");
      if (cb) cb();
    } else {
      this.el.classList.remove("minified");
      document.body.classList.remove("hs-overlay-minified");
      if (cb) cb();
    }
  }
  overlayClick(evt) {
    if (evt.target.id && `#${evt.target.id}` === this.el.id && this.isCloseWhenClickInside && this.hasAbilityToCloseOnBackdropClick) {
      this.close();
    }
  }
  backdropClick() {
    this.close();
  }
  init() {
    this.createCollection(window.$hsOverlayCollection, this);
    if (this.isLayoutAffect && this.openedBreakpoint) {
      const instance = _HSOverlay.getInstance(this.el, true);
      _HSOverlay.setOpened(
        this.openedBreakpoint,
        instance
      );
    }
    this.onOverlayClickListener = (evt) => this.overlayClick(evt);
    this.el.addEventListener("click", this.onOverlayClickListener);
    if (this.toggleButtons.length) this.buildToggleButtons(this.toggleButtons);
    if (this.toggleMinifierButtons.length) this.buildToggleMinifierButtons();
    if (typeof window !== "undefined") {
      if (!window.HSAccessibilityObserver) {
        window.HSAccessibilityObserver = new accessibility_manager_default();
      }
      this.setupAccessibility();
    }
  }
  buildToggleButtons(buttons) {
    buttons.forEach((el) => {
      if (this.el.classList.contains("opened")) el.ariaExpanded = "true";
      else el.ariaExpanded = "false";
      this.onElementClickListener.push({
        el,
        fn: () => this.elementClick()
      });
      el.addEventListener(
        "click",
        this.onElementClickListener.find(
          (toggleButton) => toggleButton.el === el
        ).fn
      );
    });
  }
  buildToggleMinifierButtons() {
    this.toggleMinifierButtons.forEach((el) => {
      if (this.el.classList.contains("minified")) el.ariaExpanded = "true";
      else el.ariaExpanded = "false";
      this.onElementMinifierClickListener.push({
        el,
        fn: () => this.elementMinifierClick()
      });
      el.addEventListener(
        "click",
        this.onElementMinifierClickListener.find(
          (minifierButton) => minifierButton.el === el
        ).fn
      );
    });
  }
  hideAuto() {
    const time = parseInt(getClassProperty(this.el, "--auto-hide", "0"));
    if (time) {
      this.autoHide = setTimeout(() => {
        this.close();
      }, time);
    }
  }
  checkTimer() {
    if (this.autoHide) {
      clearTimeout(this.autoHide);
      this.autoHide = null;
    }
  }
  buildBackdrop() {
    const overlayClasses = this.el.classList.value.split(" ");
    const overlayZIndex = parseInt(
      window.getComputedStyle(this.el).getPropertyValue("z-index")
    );
    const backdropId = this.el.getAttribute("data-hs-overlay-backdrop-container") || false;
    this.backdrop = document.createElement("div");
    let backdropClasses = `${this.backdropClasses} ${this.backdropExtraClasses}`;
    const closeOnBackdrop = getClassProperty(this.el, "--overlay-backdrop", "true") !== "static";
    const disableBackdrop = getClassProperty(this.el, "--overlay-backdrop", "true") === "false";
    this.backdrop.id = `${this.el.id}-backdrop`;
    if ("style" in this.backdrop) {
      this.backdrop.style.zIndex = `${overlayZIndex - 1}`;
    }
    for (const value of overlayClasses) {
      if (value.startsWith("hs-overlay-backdrop-open:") || value.includes(":hs-overlay-backdrop-open:")) {
        backdropClasses += ` ${value}`;
      }
    }
    if (disableBackdrop) return;
    if (backdropId) {
      this.backdrop = document.querySelector(backdropId).cloneNode(true);
      this.backdrop.classList.remove("hidden");
      backdropClasses = `${this.backdrop.classList.toString()}`;
      this.backdrop.classList.value = "";
    }
    if (closeOnBackdrop) {
      this.onBackdropClickListener = () => this.backdropClick();
      this.backdrop.addEventListener(
        "click",
        this.onBackdropClickListener,
        true
      );
    }
    this.backdrop.setAttribute("data-hs-overlay-backdrop-template", "");
    this.backdropParent.appendChild(this.backdrop);
    setTimeout(() => {
      this.backdrop.classList.value = backdropClasses;
    });
  }
  destroyBackdrop() {
    const backdrop = document.querySelector(
      `#${this.el.id}-backdrop`
    );
    if (!backdrop) return;
    if (this.openNextOverlay) {
      backdrop.style.transitionDuration = `${parseFloat(
        window.getComputedStyle(backdrop).transitionDuration.replace(/[^\d.-]/g, "")
      ) * 1.8}s`;
    }
    backdrop.classList.add("opacity-0");
    afterTransition(backdrop, () => {
      backdrop.remove();
    });
  }
  focusElement() {
    const input = this.el.querySelector("[autofocus]");
    if (!input) return false;
    else input.focus();
  }
  getScrollbarSize() {
    let div = document.createElement("div");
    div.style.overflow = "scroll";
    div.style.width = "100px";
    div.style.height = "100px";
    document.body.appendChild(div);
    let scrollbarSize = div.offsetWidth - div.clientWidth;
    document.body.removeChild(div);
    return scrollbarSize;
  }
  collectToggleParameters(buttons) {
    let toggleData = {};
    buttons.forEach((el) => {
      const data = el.getAttribute("data-hs-overlay-options");
      const dataOptions = data ? JSON.parse(data) : {};
      toggleData = {
        ...toggleData,
        ...dataOptions
      };
    });
    return toggleData;
  }
  isElementVisible() {
    const style = window.getComputedStyle(this.el);
    if (style.display === "none" || style.visibility === "hidden" || style.opacity === "0") {
      return false;
    }
    const rect = this.el.getBoundingClientRect();
    if (rect.width === 0 || rect.height === 0) {
      return false;
    }
    let parent = this.el.parentElement;
    while (parent) {
      const parentStyle = window.getComputedStyle(parent);
      if (parentStyle.display === "none" || parentStyle.visibility === "hidden" || parentStyle.opacity === "0") {
        return false;
      }
      parent = parent.parentElement;
    }
    return true;
  }
  isOpened() {
    return this.el.classList.contains("open") && !this.el.classList.contains(this.hiddenClass);
  }
  // Public methods
  open(cb = null) {
    if (this.el.classList.contains("minified")) {
      this.minify(false);
    }
    if (this.hasDynamicZIndex) {
      if (_HSOverlay.currentZIndex < this.initialZIndex) {
        _HSOverlay.currentZIndex = this.initialZIndex;
      }
      _HSOverlay.currentZIndex++;
      this.el.style.zIndex = `${_HSOverlay.currentZIndex}`;
    }
    const openedOverlays = document.querySelectorAll(".hs-overlay.open");
    const currentlyOpened = window.$hsOverlayCollection.find(
      (el) => Array.from(openedOverlays).includes(el.element.el) && !el.element.isLayoutAffect
    );
    const toggles = document.querySelectorAll(
      `[data-hs-overlay="#${this.el.id}"]`
    );
    const disabledScroll = getClassProperty(this.el, "--body-scroll", "false") !== "true";
    this.lastFocusedToggle = document.activeElement;
    if (this.isClosePrev && currentlyOpened) {
      this.openNextOverlay = true;
      return currentlyOpened.element.close().then(() => {
        this.open();
        this.openNextOverlay = false;
      });
    }
    if (disabledScroll) {
      document.body.style.overflow = "hidden";
      if (this.emulateScrollbarSpace) {
        document.body.style.paddingRight = `${this.getScrollbarSize()}px`;
      }
    }
    this.buildBackdrop();
    this.checkTimer();
    this.hideAuto();
    toggles.forEach((toggle) => {
      if (toggle.ariaExpanded) toggle.ariaExpanded = "true";
    });
    this.el.classList.remove(this.hiddenClass);
    this.el.setAttribute("aria-overlay", "true");
    this.el.setAttribute("tabindex", "-1");
    setTimeout(() => {
      if (this.el.classList.contains("opened")) return false;
      this.el.classList.add("open", "opened");
      if (this.isLayoutAffect) {
        document.body.classList.add("hs-overlay-body-open");
      }
      if (!this.initiallyOpened) {
        this.el.focus();
        this.el.style.outline = "none";
      }
      this.initiallyOpened = false;
      this.fireEvent("open", this.el);
      dispatch("open.hs.overlay", this.el, this.el);
      if (window.HSAccessibilityObserver && this.accessibilityComponent) {
        window.HSAccessibilityObserver.updateComponentState(
          this.accessibilityComponent,
          true
        );
      }
      if (this.hasAutofocus) this.focusElement();
      if (typeof cb === "function") cb();
      if (this.isElementVisible()) _HSOverlay.openedItemsQty++;
    }, 50);
  }
  close(forceClose = false, cb = null) {
    if (this.isElementVisible()) {
      _HSOverlay.openedItemsQty = _HSOverlay.openedItemsQty <= 0 ? 0 : _HSOverlay.openedItemsQty - 1;
    }
    if (_HSOverlay.openedItemsQty === 0 && this.isLayoutAffect) {
      document.body.classList.remove("hs-overlay-body-open");
    }
    const closeFn = (_cb) => {
      if (this.el.classList.contains("open")) return false;
      const toggles = document.querySelectorAll(
        `[data-hs-overlay="#${this.el.id}"]`
      );
      toggles.forEach((toggle) => {
        if (toggle.ariaExpanded) toggle.ariaExpanded = "false";
      });
      this.el.classList.add(this.hiddenClass);
      if (this.hasDynamicZIndex) this.el.style.zIndex = "";
      this.destroyBackdrop();
      this.fireEvent("close", this.el);
      dispatch("close.hs.overlay", this.el, this.el);
      if (window.HSAccessibilityObserver && this.accessibilityComponent) {
        window.HSAccessibilityObserver.updateComponentState(
          this.accessibilityComponent,
          false
        );
      }
      if (!document.querySelector(".hs-overlay.opened")) {
        document.body.style.overflow = "";
        if (this.emulateScrollbarSpace) document.body.style.paddingRight = "";
      }
      if (this.lastFocusedToggle) {
        this.lastFocusedToggle.focus();
        this.lastFocusedToggle = null;
      }
      _cb(this.el);
      if (typeof cb === "function") cb();
      if (_HSOverlay.openedItemsQty === 0) {
        document.body.classList.remove("hs-overlay-body-open");
        if (this.hasDynamicZIndex) _HSOverlay.currentZIndex = 0;
      }
    };
    return new Promise((resolve) => {
      this.el.classList.remove("open", "opened");
      this.el.removeAttribute("aria-overlay");
      this.el.removeAttribute("tabindex");
      this.el.style.outline = "";
      if (forceClose) closeFn(resolve);
      else afterTransition(this.animationTarget, () => closeFn(resolve));
    });
  }
  updateToggles() {
    const found = Array.from(
      document.querySelectorAll(
        `[data-hs-overlay="#${this.el.id}"]`
      )
    );
    const newButtons = found.filter((btn) => !this.toggleButtons.includes(btn));
    if (newButtons.length) {
      this.toggleButtons.push(...newButtons);
      this.buildToggleButtons(newButtons);
    }
    this.toggleButtons = this.toggleButtons.filter((btn) => {
      var _a;
      if (document.contains(btn)) return true;
      const listener = (_a = this.onElementClickListener) == null ? void 0 : _a.find(
        (lst) => lst.el === btn
      );
      if (listener) btn.removeEventListener("click", listener.fn);
      return false;
    });
  }
  destroy() {
    this.el.classList.remove("open", "opened", this.hiddenClass);
    if (this.isLayoutAffect) {
      document.body.classList.remove("hs-overlay-body-open");
    }
    this.el.removeEventListener("click", this.onOverlayClickListener);
    if (this.onElementClickListener.length) {
      this.onElementClickListener.forEach(({ el, fn }) => {
        el.removeEventListener("click", fn);
      });
      this.onElementClickListener = null;
    }
    if (this.backdrop) {
      this.backdrop.removeEventListener("click", this.onBackdropClickListener);
    }
    if (this.backdrop) {
      this.backdrop.remove();
      this.backdrop = null;
    }
    window.$hsOverlayCollection = window.$hsOverlayCollection.filter(
      ({ element }) => element.el !== this.el
    );
  }
  // Static methods
  static findInCollection(target) {
    return window.$hsOverlayCollection.find((el) => {
      if (target instanceof _HSOverlay) return el.element.el === target.el;
      else if (typeof target === "string") {
        return el.element.el === document.querySelector(target);
      } else return el.element.el === target;
    }) || null;
  }
  static getInstance(target, isInstance) {
    const _temp = typeof target === "string" ? document.querySelector(target) : target;
    const _target = (_temp == null ? void 0 : _temp.getAttribute("data-hs-overlay")) ? _temp.getAttribute("data-hs-overlay") : target;
    const elInCollection = window.$hsOverlayCollection.find(
      (el) => el.element.el === (typeof _target === "string" ? document.querySelector(_target) : _target) || el.element.el === (typeof _target === "string" ? document.querySelector(_target) : _target)
    );
    return elInCollection ? isInstance ? elInCollection : elInCollection.element.el : null;
  }
  static autoInit() {
    if (!window.$hsOverlayCollection) {
      window.$hsOverlayCollection = [];
    }
    if (window.$hsOverlayCollection) {
      window.$hsOverlayCollection = window.$hsOverlayCollection.filter(
        ({ element }) => document.contains(element.el)
      );
    }
    document.querySelectorAll(".hs-overlay:not(.--prevent-on-load-init)").forEach((el) => {
      if (!window.$hsOverlayCollection.find(
        (elC) => {
          var _a;
          return ((_a = elC == null ? void 0 : elC.element) == null ? void 0 : _a.el) === el;
        }
      )) {
        new _HSOverlay(el);
      }
    });
  }
  static open(target) {
    const instance = _HSOverlay.findInCollection(target);
    if (instance && instance.element.el.classList.contains(instance.element.hiddenClass)) instance.element.open();
  }
  static close(target) {
    const instance = _HSOverlay.findInCollection(target);
    if (instance && !instance.element.el.classList.contains(instance.element.hiddenClass)) instance.element.close();
  }
  static minify(target, isMinified) {
    const instance = _HSOverlay.findInCollection(target);
    if (instance) {
      instance.element.minify(isMinified);
    }
  }
  static setOpened(breakpoint, el) {
    if (document.body.clientWidth >= breakpoint) {
      if (el.element.el.classList.contains("minified")) {
        el.element.minify(false);
      }
      document.body.classList.add("hs-overlay-body-open");
      el.element.open();
    } else el.element.close(true);
  }
  // Accessibility methods
  setupAccessibility() {
    this.accessibilityComponent = window.HSAccessibilityObserver.registerComponent(
      this.el,
      {
        onEnter: () => {
          if (!this.isOpened()) this.open();
        },
        onEsc: () => {
          if (this.isOpened()) {
            this.close();
          }
        },
        onTab: () => {
          var _a;
          if (!this.isOpened() || !this.isTabAccessibilityLimited) return;
          const focusableElements = Array.from(
            this.el.querySelectorAll(
              'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
            )
          ).filter(
            (el) => !el.hidden && window.getComputedStyle(el).display !== "none"
          );
          if (focusableElements.length === 0) return;
          const focusedElement = this.el.querySelector(":focus");
          const currentIndex = focusedElement ? focusableElements.indexOf(focusedElement) : -1;
          const isShiftPressed = window.event instanceof KeyboardEvent && window.event.shiftKey;
          if (isShiftPressed) {
            if (currentIndex <= 0) {
              focusableElements[focusableElements.length - 1].focus();
            } else {
              focusableElements[currentIndex - 1].focus();
            }
          } else {
            if (currentIndex === focusableElements.length - 1) {
              focusableElements[0].focus();
            } else {
              focusableElements[currentIndex + 1].focus();
            }
          }
          (_a = window.event) == null ? void 0 : _a.preventDefault();
        }
      },
      this.isOpened(),
      "Overlay",
      ".hs-overlay"
    );
    this.toggleButtons.forEach((toggleButton) => {
      window.HSAccessibilityObserver.registerComponent(
        toggleButton,
        {
          onEnter: () => {
            if (!this.isOpened()) this.open();
          },
          onEsc: () => {
            if (this.isOpened()) {
              this.close();
            }
          }
        },
        this.isOpened(),
        "Overlay Toggle",
        `[data-hs-overlay="#${this.el.id}"]`
      );
    });
  }
  // Backward compatibility
  static on(evt, target, cb) {
    const instance = _HSOverlay.findInCollection(target);
    if (instance) instance.element.events[evt] = cb;
  }
};
__publicField(_HSOverlay, "openedItemsQty", 0);
__publicField(_HSOverlay, "currentZIndex", 0);
var HSOverlay = _HSOverlay;
var resizeTimeout = null;
var debounceResize = (callback, delay = 150) => {
  if (resizeTimeout) clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(callback, delay);
};
var autoCloseResizeFn = () => {
  if (!window.$hsOverlayCollection.length || !window.$hsOverlayCollection.find((el) => el.element.autoClose)) {
    return false;
  }
  const overlays = window.$hsOverlayCollection.filter(
    (el) => el.element.autoClose
  );
  overlays.forEach((overlay) => {
    const { autoCloseEqualityType, autoClose } = overlay.element;
    const condition = autoCloseEqualityType === "less-than" ? document.body.clientWidth <= autoClose : document.body.clientWidth >= autoClose;
    if (condition && overlay.element.el.classList.contains("opened")) {
      if (overlay.element.el.classList.contains("minified")) {
        overlay.element.minify(false);
      }
      overlay.element.close(true);
    } else {
      if (overlay.element.isLayoutAffect && overlay.element.el.classList.contains("opened")) {
        document.body.classList.add("hs-overlay-body-open");
      }
    }
  });
};
var moveOverlayToBodyResizeFn = () => {
  if (!window.$hsOverlayCollection.length || !window.$hsOverlayCollection.find((el) => el.element.moveOverlayToBody)) {
    return false;
  }
  const overlays = window.$hsOverlayCollection.filter(
    (el) => el.element.moveOverlayToBody
  );
  overlays.forEach((overlay) => {
    const resolution = overlay.element.moveOverlayToBody;
    const initPlace = overlay.element.initContainer;
    const newPlace = document.querySelector("body");
    const target = overlay.element.el;
    if (!initPlace && target) return false;
    if (document.body.clientWidth <= resolution && !isDirectChild(newPlace, target)) {
      newPlace.appendChild(target);
    } else if (document.body.clientWidth > resolution && !initPlace.contains(target)) {
      initPlace.appendChild(target);
    }
  });
};
var setOpenedResizeFn = () => {
  if (!window.$hsOverlayCollection.length || !window.$hsOverlayCollection.find((el) => el.element.openedBreakpoint)) {
    return false;
  }
  const overlays = window.$hsOverlayCollection.filter(
    (el) => el.element.openedBreakpoint
  );
  overlays.forEach((overlay) => {
    const { openedBreakpoint } = overlay.element;
    const condition = document.body.clientWidth >= openedBreakpoint;
    if (condition) {
      if (!overlay.element.el.classList.contains("opened")) {
        HSOverlay.setOpened(openedBreakpoint, overlay);
      }
    } else {
      if (overlay.element.el.classList.contains("opened")) {
        if (overlay.element.el.classList.contains("minified")) {
          overlay.element.minify(false);
        }
        overlay.element.close(true);
      }
    }
  });
};
var setBackdropZIndexResizeFn = () => {
  if (!window.$hsOverlayCollection.length || !window.$hsOverlayCollection.find(
    (el) => el.element.el.classList.contains("opened")
  )) {
    return false;
  }
  const overlays = window.$hsOverlayCollection.filter(
    (el) => el.element.el.classList.contains("opened")
  );
  overlays.forEach((overlay) => {
    const overlayZIndex = parseInt(
      window.getComputedStyle(overlay.element.el).getPropertyValue("z-index")
    );
    const backdrop = document.querySelector(
      `#${overlay.element.el.id}-backdrop`
    );
    if (!backdrop) return false;
    const backdropZIndex = parseInt(
      window.getComputedStyle(backdrop).getPropertyValue("z-index")
    );
    if (overlayZIndex === backdropZIndex + 1) return false;
    if ("style" in backdrop) backdrop.style.zIndex = `${overlayZIndex - 1}`;
    document.body.classList.add("hs-overlay-body-open");
  });
};
var ensureBodyOpenForMinifiedSidebar = () => {
  var _a;
  if (!((_a = window.$hsOverlayCollection) == null ? void 0 : _a.length)) return;
  window.$hsOverlayCollection.forEach((overlayItem) => {
    var _a2;
    const overlay = overlayItem.element;
    if (((_a2 = overlay.toggleMinifierButtons) == null ? void 0 : _a2.length) > 0 && overlay.openedBreakpoint) {
      if (document.body.clientWidth >= overlay.openedBreakpoint) {
        document.body.classList.add("hs-overlay-body-open");
      } else {
        document.body.classList.remove("hs-overlay-body-open");
      }
    }
  });
};
window.addEventListener("load", () => {
  HSOverlay.autoInit();
  moveOverlayToBodyResizeFn();
  ensureBodyOpenForMinifiedSidebar();
});
window.addEventListener("resize", () => {
  debounceResize(() => {
    autoCloseResizeFn();
    setOpenedResizeFn();
  });
  moveOverlayToBodyResizeFn();
  setBackdropZIndexResizeFn();
  ensureBodyOpenForMinifiedSidebar();
});
if (typeof window !== "undefined") {
  window.HSOverlay = HSOverlay;
}
var overlay_default = HSOverlay;
export {
  overlay_default as default
};
/*! Bundled license information:

preline/src/plugins/overlay/index.ts:
  (*
   * HSOverlay
   * @version: 3.2.3
   * @author: Preline Labs Ltd.
   * @license: Licensed under MIT and Preline UI Fair Use License (https://preline.co/docs/license.html)
   * Copyright 2024 Preline Labs Ltd.
   *)
*/
//# sourceMappingURL=preline_src_plugins_overlay.js.map
